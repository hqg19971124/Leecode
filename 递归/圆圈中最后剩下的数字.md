## 剑指 Offer 62. 圆圈中最后剩下的数字


https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/


### 题目描述

```
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
 

限制：

1 <= n <= 10^5
1 <= m <= 10^6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```



### 思路

```
我们用 f(n, m) 表示从 n 个数中每次删除第 m 个数（共删除了 n - 1 次），最后留下的那个数的序号。

我们从 f(n, m) 场景下删除的第 1 个数是从序号 0 开始，向后数 m 个数得到的。删除第一个数后，将剩下 n - 1 个数，此时场景变为 f(n - 1, m)，用于表示从 n - 1 个数中每次删除第 m 个数最后留下的数的序号。

在往下看之前，我们先达成一个共识：f(n, m) 与 f(n - 1, m) 得到的数是同一个数（最后剩下的数在每一轮中都不可能被删除），只是在它们所在的场景下，这个数字的序号不同罢了。

那么，何谓「所在场景，序号不同」？

这里所说的「序号」与所在场景下首次选取删除数字的出发点有关，我们直接看下题目给出的 n = 5, m = 3 这个例子，已知答案为 3。

不同场景下的不同序号
f(n, m) 场景
此时 n = 5，由于我们从第 1 个数字出发，所以从第 1 个数字开始编号：


数字：
0 1 2 3 4
序号：
0 1 2 3 4
可以看到答案 3 在该场景下的序号为 3。

f(n - 1, m) 场景
此时，我们已经在 f(n, m) 场景下删除一个数了，这个数是 2，因此我们要从 3 开始重新编号：


数字：
0 1 3 4
序号：
2 3 0 1
答案 3 在该场景下的序号为 0。

两者序号的关系
我们知道，从 f(n - m) 场景下删除的第一个数的序号是 (m - 1) % n，那么 f(n - 1, m) 场景将使用被删除数字的下一个数，即序号 m % n 作为它的 0 序号。

设 f(n - 1, m) 的结果为 x，x 是从 f(n, m) 场景下序号为 m % n 的数字出发所获得的结果，因此，我们可以得出：m % n + x 是该数字在 f (n, m) 场景下的结果序号。即：


f(n, m) = m % n + x
但由于 m % n + x 可能会超过 n 的范围，所以我们再取一次模：


f(n , m) = (m % n + x) % n = (m + x) % n
将 f(n - 1, m) 代回，得到递推公式：


f(n, m) = (m + f(n - 1, m)) % n
有了递推公式后，想递归就递归，想迭代就迭代咯~

作者：jalan
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jie-shi-di-tui-gong-shi-di-gui-die-dai-sui-bian-xi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### python代码
执行用时：
216 ms
, 在所有 Python3 提交中击败了
29.28%
的用户
内存消耗：
120 MB
, 在所有 Python3 提交中击败了
5.02%
的用户
```
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        def f(n,m):
            if(n==0):
                return 0
            x=f(n-1,m)
            return (m+x)%n

        return f(n,m)

```

